'use strict';

var DATE_TYPES = {
  'date'     : 2,
  'datetime' : 3,
  'time'     : -2
};

var DST_MASK            = 0xc000;
var UTC_OFFSET_BYTESIZE = 2;
var UTC_MASK            = 0x3fff;

var ext  = require('./ext');
var util = require('util');
var Long = require('long');

function signExtend(val, size) {
  var mask = Long.fromInt(1).shiftLeft((size * 8) - 1)
  return Long.fromNumber(val).xor(mask).subtract(mask);
}

function signExtendTZ(val) {
  val  = val & 0x3FFF;
  var mask = 0x2000;

  if (val & mask) {
    val += 0xFFFFC000;
  }

  return val << 0;
}


function pow2(bits) {
  return Math.pow(2, bits);
}


function getTimeValue(buffer, size) {
  var value = 0;

  for (var i = 0; i < size; i++) {
    var bits        = ((size-1) - i) * 8; // big-endian
    var shiftedData = buffer[i] * pow2(bits);

    value += shiftedData;
  }

  return value;
}


function getSecondsAndSlice(descriptor, buf) {
  var seconds = 0;
  var newBuf  = buf;

  if(descriptor & 0x80) {
    var size = ((descriptor & 0x1c) >> 2) + 1 ;
    seconds  = getTimeValue(buf, size);
    seconds  = signExtend(seconds, size);

    newBuf = buf.slice(size);
  }

  return {
    'buffer'  : newBuf,
    'value'   : seconds
  }
}


function getNanosecondsAndSlice(descriptor, buf) {
  var nanoseconds = 0;
  var newBuf      = buf;

  if(descriptor & 0x40) {
    var size    = ((descriptor & 0x03) + 1)
    nanoseconds = getTimeValue(buf, size);

    newBuf = buf.slice(size);
  }

  return {
    'buffer'  : newBuf,
    'value'   : nanoseconds
  }
}

function getUtcOffsetAndSlice(descriptor, buf) {
  var tz_offset = 0;
  var isdst     = null;
  var newBuf    = buf;

  if(descriptor & 0x20) {
    var size       = UTC_OFFSET_BYTESIZE;
    var masked_utc = getTimeValue(buf, size);

    tz_offset = masked_utc & UTC_MASK;
    tz_offset = signExtendTZ(tz_offset);
    isdst     = ( masked_utc & DST_MASK ) != 0;

    newBuf = buf.slice(size);
  }

  return {
    'buffer'  : newBuf,
    'isdst'   : isdst,
    'value'   : tz_offset
  }
}


function createDateObj(descriptor, type, buf) {
  var rSec  = getSecondsAndSlice(descriptor, buf);
  var rNsec = getNanosecondsAndSlice(descriptor, rSec['buffer']);
  var rUtc  = getUtcOffsetAndSlice(descriptor, rNsec['buffer']);

  var nsec = rNsec['value'];
  var msec = (rSec['value'] * 1000) + (nsec / 1000000);
  var tz   = -rUtc['value'];

  switch(type) {
    case DATE_TYPES['date']:
      var obj = new ext.Date(msec);
      break;
    case DATE_TYPES['datetime']:
      var obj = new ext.DateTime(msec);
      obj.setNanoseconds(nsec);
      break;
    case DATE_TYPES['time']:
      var obj = new ext.Time(msec);
      obj.setNanoseconds(nsec);
      break;
    default:
      throw "ext type not recognized"
  }

  return obj;
}


function isDate(obj) {
  var buf  = obj['_msgpack_packed_data'];
  var type = obj['_msgpack_packed_type'];

  var keys               = Object.keys(DATE_TYPES)
  var supportedDateTypes = keys.map(function (k) { return DATE_TYPES[k] });

  return buf  !== undefined &&
         type !== undefined &&
         supportedDateTypes.indexOf(type) !== -1;
}

// * This function accepts a hash that has been unpacked from calling msgpack.unpack.
//
// example input:{ data: <Buffer ef 53 4c f3 b4 15 38 21 00 01 e0>, type: 2 }
function unpack(obj) {
  var buf  = obj['_msgpack_packed_data'];
  var type = obj['_msgpack_packed_type'];

  return createDateObj(buf[0], type, buf.slice(1));
}

module.exports.unpack = unpack;
module.exports.isDate = isDate;
