#include "date.h"

Handle<Value> _simple_date_get(Handle<Date> date, const char *func_name) {
  Handle<Function> func = Handle<Function>::Cast(date->Get(String::New(func_name)));
  return func->Call(date, 0, NULL);
}

void _simple_date_set(Handle<Date> date, const char *func_name, Handle<Value> argv[]) {
  Handle<Function> func = Handle<Function>::Cast(date->Get(String::New(func_name)));
  func->Call(date, 1, argv);
}

/*
 * Hack-ege!! Half-hack, half-sacrilege
 *
 * Implementation: Get maximum timezone offset between January and July and
 * compare the result to the current timezone offset. If the current offset is
 * less than the result, then the current date is in dst
 *
 * Note: There's an assumption here that this January-July scenario holds true
 * for all places. Please refer to: http://javascript.about.com/library/bldst.htm
 *
 */
bool _is_dst(Handle<Date> pivot_date) {
  double d  = static_cast<double>(_simple_date_get(pivot_date, "getTime")->NumberValue());

  // january
  Handle<Date> jan = Handle<Date>::Cast(v8::Date::New(d));
  Handle<Value> arg_jan[1] = { Integer::New(0) };
  _simple_date_set(jan, "setUTCMonth", arg_jan);
  int64_t jan_offset = _simple_date_get(jan, "getTimezoneOffset")->IntegerValue();

  // july
  Handle<Date> jul = Handle<Date>::Cast(v8::Date::New(d));
  Handle<Value> arg_jul[1] = { Integer::New(6) };
  _simple_date_set(jul, "setUTCMonth", arg_jul);
  int64_t jul_offset = _simple_date_get(jul, "getTimezoneOffset")->IntegerValue();

  int64_t dst_offset    = std::max(jan_offset, jul_offset);
  int64_t actual_offset = _simple_date_get(pivot_date, "getTimezoneOffset")->IntegerValue();

  return actual_offset < dst_offset;
}

