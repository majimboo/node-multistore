#ifndef MSGPACK_BIG_INTEGER_HPP__
#define MSGPACK_BIG_INTEGER_HPP__

#include <string>
#include <sstream>
#include "msgpack/exception.hpp"

namespace msgpack {
    namespace big_integer {
        const Persistent<String> kSignum      = NODE_PSYMBOL("signum");
        const Persistent<String> kToByteArray = NODE_PSYMBOL("toByteArray");
        Persistent<Function> constructor;

        void SetConstructor(Handle<Function> ctor) {
            constructor = Persistent<Function>::New(ctor);
        }

        Handle<Value> Create(std::string str) {
            const unsigned argc     = 1;
            Local<Value> argv[argc] = { String::New(str.c_str()) };

            return constructor->NewInstance(argc, argv);
        }

        bool IsBigInteger(Handle<Value> v8obj) {
            Local<Object> o = v8obj->ToObject();

            return o->Has(kSignum) && o->Get(kSignum)->IsFunction() &&
                       o->Has(kToByteArray) && o->Get(kToByteArray)->IsFunction();
        }

        int8_t Signum(Handle<Value> v8obj) {
            Local<Object> o = v8obj->ToObject();
            Local<Function> getSignum = Local<Function>::Cast(o->Get(kSignum));

            return static_cast<int8_t>(getSignum->Call(o, 0, NULL)->Int32Value());
        }

        int64_t Int64Value(Handle<Value> v8obj) {
            const Local<Object> o = v8obj->ToObject();
            const Local<Function> to_byte_array = Local<Function>::Cast(o->Get(kToByteArray));
            const Local<Array>  a = Local<Array>::Cast(to_byte_array->Call(o, 0, NULL));
            const int8_t signum = Signum(v8obj);
            uint32_t length = a->Length();
            uint8_t start_index = 0;
            const uint8_t last_index  = length;
            int64_t result = 0;

            // If negative, then max size is only 8 bytes
            // If positive, BigInteger includes an additional 1 byte; presumably
            // because toByteArray always returns a signed integer; so maximum
            // allowed array length is 9, given that the first byte is equal to 0
            // (positive);
            if (length > 8 && !(signum > 0 && length == 9 && a->Get(0)->IntegerValue() == 0)) {
                throw MsgpackException("BigIntegers greater than 64bit not yet supported");
            }

            // If positive, we "slice" Array to remove the extra byte
            if (signum > 0 && length == 9 && a->Get(0)->IntegerValue() == 0) {
                start_index = 1;
                length      = 8;
            }

#ifdef __LITTLE_ENDIAN__
            for (uint8_t i = start_index; i < last_index; i++) {
                uint8_t e = static_cast<uint8_t>(a->Get(i)->IntegerValue());
                result   |= static_cast<uint64_t>(e) << ( 8 * (i - start_index));
            }

            result = _msgpack_be64(result) >> ((8 - length) * 8);
#else
            for (uint32_t i = start_index, j = last_index - 1; i < last_index; i++, j--) {
                uint8_t e = static_cast<uint8_t>(a->Get(i)->IntegerValue());
                result   |= static_cast<uint64_t>(e) << ( 8 * j);
            }

            result = _msgpack_be64(result);
#endif

            // sign extend if negative
            if (signum < 0) {
                int64_t const mask = INT64_C(1) << (length * 8 - 1);
                result = (result ^ mask) - mask;
            }

            return result;
        }
    }
}

#endif
