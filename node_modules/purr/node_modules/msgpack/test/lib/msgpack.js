'use strict';

var msgpack = require("../../lib/msgpack");
var stub    = require("../fixtures/stub");
var BigInteger = require('bignumber').BigInteger;

function _set_up(callback) {
  this.backup = {};

  this.testCircular = function (data, test) {
    try {
      msgpack.pack(data);
      test.ok(false, 'expected exception');
    } catch (e) {
      test.equal(
        e.message,
        'Cowardly refusing to pack object with circular reference'
      );
    }
  };

  this.checkSeconds = function(date, descriptor, data, test) {
    var sec = 0;

    if (descriptor & 0x80) {
      var actual_sec = Math.floor(date.getTime() / 1000);
      var size       = ((descriptor & 0x1c) >> 2) + 1 ;

      for (var i = 0; i < size; i++) {
        var bits         = ((size-1) - i) * 8; // big-endian
        var shifted_data = data[i] * Math.pow(2, bits);

        sec += shifted_data;
      }
      test.ok(sec == actual_sec, "invalid conversion of seconds");

      data = data.slice(size);
    } else {
      test.ok(false, "invalid seconds received");
    }

    return [data, sec];
  };

  this.checkNanoseconds = function(date, descriptor, data, test) {
    var nsec = 0;

    if(descriptor & 0x40) {
      var actual_nsec = date.getMilliseconds() * 1000000;
      var size        = ((descriptor & 0x03) + 1)

      for(var i = 0; i < size; i++) {
        var bits         = ((size-1) - i) * 8; // big-endian
        var shifted_data = data[i] * Math.pow(2, bits);

        nsec += shifted_data;
      }

      test.ok(nsec == actual_nsec, "invalid conversion of nanoseconds");

      data = data.slice(size);
    } else {
      test.ok(false, "invalid nanoseconds received");
    }

    return [data, nsec];
  };


  this.checkTZ = function(date, descriptor, data, test) {
    if(descriptor & 0x20) {
      // * invert sign because javascript's utc implementation is reversed
      var actual_utc = -( date.getTimezoneOffset() >>> 0 ) & 0x3fff;
      var size       = 2;
      var masked_utc = 0;

      for(var i = 0; i < size; i++) {
        var bits         = ((size-1) - i) * 8; // big-endian
        var shifted_data = data[i] * Math.pow(2, bits);

        masked_utc += shifted_data;
      }

      var utc = masked_utc & 0x3fff;

      // test timezone offset
      test.ok(utc == actual_utc, "invalid conversion of utc offset");

      // test dst detection
      var is_dst = ( masked_utc & 0xC000 ) != 0;

      // hack based on: http://javascript.about.com/library/bldst.htm
      // to check if we're currently in dst
      var january = new Date(date.getFullYear(), 0, 1);
      var july    = new Date(date.getFullYear(), 6, 1);
      var offset  = Math.max(january.getTimezoneOffset(),
                             july.getTimezoneOffset());

      var actual_is_dst = date.getTimezoneOffset() < offset;

      test.ok(is_dst == actual_is_dst, "dst flags are not the same");

      data = data.slice(size);
    } else {
      test.ok(false, "invalid utc offset received");
    }

    return data;
  }

  callback();
}

function _tear_down(callback) {
  callback();
}

function createRawExt(format, type, size) {
  var totalSize = size;
  var writeSize;
  var typeOffset;
  var raw;

  switch (format) {
    case 0xd4:
    case 0xd5:
    case 0xd6:
    case 0xd7:
    case 0xd8:
      totalSize += 2;
      typeOffset = 1;
      break;

    case 0xc7:
      totalSize += 3;
      writeSize  = 'writeUInt8';
      typeOffset = 2;
      break;
    case 0xc8:
      totalSize += 4;
      writeSize  = 'writeUInt16BE';
      typeOffset = 3;
      break;
    case 0xc9:
      totalSize += 6;
      writeSize = 'writeUInt32BE';
      typeOffset = 5;
      break;
  }

  raw = new Buffer(totalSize);
  raw.fill(1);
  raw.writeUInt8(format, 0);
  raw.writeInt8(type, typeOffset);

  if (writeSize) {
    raw[writeSize](size, 1);
  }

  return raw
}

function createExpectedExtBuffer(type, size) {
  var data = new Buffer(size);
  data.fill(1);

  return {
    _msgpack_packed_data: data,
    _msgpack_packed_type: type
  }
}

exports.msgpack = {
  setUp : _set_up,
  tearDown : _tear_down,
  'should be object' : function (test) {
    test.expect(2);
    test.isNotNull(msgpack);
    test.isObject(msgpack);
    test.done();
  },
  'pack should return a Buffer object' : function (test) {
    test.expect(2);
    var buf = msgpack.pack('abcdef');
    test.isNotNull(buf);
    test.isBuffer(buf);
    test.done();
  },
  'test for string equality' : function (test) {
    test.expect(1);
    test.deepEqual('abcdef', msgpack.unpack(msgpack.pack('abcdef')));
    test.done();
  },
//  'test unpacking a buffer' : function (test) {
//    test.expect(1);
//    var testBuffer = new Buffer([0x00, 0x01, 0x02]);
//    test.deepEqual(testBuffer, msgpack.unpack(msgpack.pack(testBuffer), true));
//    test.done();
//  },
  'test for numeric equality' : function (test) {
    test.expect(2);
    test.deepEqual(123, msgpack.unpack(msgpack.pack(123)));
    test.isNumber(msgpack.unpack(msgpack.pack(123)));
    test.done();
  },
  'test for null' : function (test) {
    test.expect(2);
    test.deepEqual(null, msgpack.unpack(msgpack.pack(null)));
    test.isNull(msgpack.unpack(msgpack.pack(null)));
    test.done();
  },
  'test for negative decimal number' : function (test) {
    test.expect(2);
    test.deepEqual(-1243.111, msgpack.unpack(msgpack.pack(-1243.111)));
    test.isNumber(msgpack.unpack(msgpack.pack(-1243.111)));
    test.done();
  },
  'test for negative number' : function (test) {
    test.expect(2);
    test.deepEqual(-123, msgpack.unpack(msgpack.pack(-123)));
    test.isNumber(msgpack.unpack(msgpack.pack(-123)));
    test.done();
  },
  'test for true' : function (test) {
    test.expect(2);
    test.deepEqual(true, msgpack.unpack(msgpack.pack(true)));
    test.isBoolean(msgpack.unpack(msgpack.pack(true)));
    test.done();
  },
  'test for false' : function (test) {
    test.expect(2);
    test.deepEqual(false, msgpack.unpack(msgpack.pack(false)));
    test.isBoolean(msgpack.unpack(msgpack.pack(false)));
    test.done();
  },
  'test for numeric array' : function (test) {
    test.expect(2);
    test.deepEqual([1,2,3], msgpack.unpack(msgpack.pack([1,2,3])));
    test.isArray(msgpack.unpack(msgpack.pack([1,2,3])));
    test.done();
  },
  'test for mixed type array' : function (test) {
    test.expect(2);
    test.deepEqual(
      [1, 'abc', false, null],
      msgpack.unpack(msgpack.pack([1, 'abc', false, null]))
    );
    test.isArray(msgpack.unpack(msgpack.pack([1,2,3])));
    test.done();
  },
  'test for object' : function (test) {
    test.expect(2);
    var object = {'a' : [1, 2, 3], 'b' : 'cdef', 'c' : {'nuts' : 'qqq'}};
    test.deepEqual(object, msgpack.unpack(msgpack.pack(object)));
    test.isObject(msgpack.unpack(msgpack.pack(object)));
    test.done();
  },
  'test for 2^31 negative' : function (test) {
    test.expect(2);
    test.deepEqual(
      0 - Math.pow(2,31) - 1,
      msgpack.unpack(msgpack.pack(0 - Math.pow(2,31) - 1))
    );
    test.isNumber(msgpack.unpack(msgpack.pack(0 - Math.pow(2,31) - 1)));
    test.done();
  },
  'test for 2^40 negative' : function (test) {
    test.expect(2);
    test.deepEqual(
      0 - Math.pow(2,40) - 1,
      msgpack.unpack(msgpack.pack(0 - Math.pow(2,40) - 1))
    );
    test.isNumber(msgpack.unpack(msgpack.pack(0 - Math.pow(2,40) - 1)));
    test.done();
  },
  'test for 2^31' : function (test) {
    test.expect(2);
    test.deepEqual(
      Math.pow(2,31) + 1,
      msgpack.unpack(msgpack.pack(Math.pow(2,31) + 1))
    );
    test.isNumber(msgpack.unpack(msgpack.pack(Math.pow(2,31) + 1)));
    test.done();
  },
  'test for 2^40' : function (test) {
    test.expect(2);
    test.deepEqual(
      Math.pow(2,40) + 1,
      msgpack.unpack(msgpack.pack(Math.pow(2,40) + 1))
    );
    test.isNumber(msgpack.unpack(msgpack.pack(Math.pow(2,40) + 1)));
    test.done();
  },
  'test number approaching 2^64' : function (test) {
    test.expect(2);
    test.deepEqual(
      123456782345245,
      msgpack.unpack(msgpack.pack(123456782345245))
    );
    test.isNumber(msgpack.unpack(msgpack.pack(123456782345245)));
    test.done();
  },
  'test BigInteger (2^64) - 1 input should return BigInteger' : function (test) {
    var i = new BigInteger('18446744073709551615');

    test.expect(2);
    test.ok(i.equals(msgpack.unpack(msgpack.pack(i))));
    test.ok(i instanceof BigInteger);
    test.done();
  },
  'test BigInteger -(2^63) input should return BigInteger' : function (test) {
    var i = new BigInteger('-9223372036854775808');

    test.expect(2);
    test.ok(i.equals(msgpack.unpack(msgpack.pack(i))));
    test.ok(i instanceof BigInteger);
    test.done();
  },
  'test BigInteger (2^53) - 1 input (JS Max Safe Integer) should return JS Number' : function (test) {
    var i = new BigInteger('9007199254740991');

    test.expect(2);
    test.deepEqual(
      9007199254740991,
      msgpack.unpack(msgpack.pack(i)));
    test.isNumber(msgpack.unpack(msgpack.pack(i)));
    test.done();
  },
  'test BigInteger -(2^53) - 1 input (JS Min Safe Integer) should return JS Number' : function (test) {
    var i = new BigInteger('-9007199254740991');

    test.expect(2);
    test.deepEqual(
      -9007199254740991,
      msgpack.unpack(msgpack.pack(i)));
    test.isNumber(msgpack.unpack(msgpack.pack(i)));
    test.done();
  },
  'test BigInteger -(2^63) - 1 input should raise error' : function (test) {
    var i = new BigInteger('-9223372036854775809');

    test.expect(1);
    test.throws(function () {
      msgpack.unpack(msgpack.pack(i));
    });
    test.done();
  },
  'test BigInteger (2^64) input should raise error' : function (test) {
    var i = new BigInteger('18446744073709551616');

    test.expect(1);
    test.throws(function () {
      msgpack.unpack(msgpack.pack(i));
    });
    test.done();
  },
  'test for circular reference' : function (test) {
    test.expect(1);
    var a = [1, 2, 3, 4];
    a.push(a);
    this.testCircular(a, test);
    test.done();
  },
  'test for circular reference in objects' : function (test) {
    test.expect(1);
    var d = {};
    d.qqq = d;
    this.testCircular(d, test);
    test.done();
  },
  'test for not catching multiple non-circular references' : function (test) {
    test.expect(2);
    var e = {};
    test.deepEqual(
      { a : e, b : e },
      msgpack.unpack(msgpack.pack({ a : e, b : e }))
    );
    test.isObject(msgpack.unpack(msgpack.pack({ a : e, b : e })));
    test.done();
  },
  'unpacking a buffer with extra data doesn\'t lose the extra data' : function (test) {
    test.expect(4);
    // Object to test with
    var o = [1, 2, 3];

    // Create two buffers full of packed data, 'b' and 'bb', with the latter
    // containing 3 extra bytes
    var b = msgpack.pack(o);
    var bb = new Buffer(b.length + 3);
    b.copy(bb, 0, 0, b.length);

    // Expect no remaining bytes when unpacking 'b'
    test.deepEqual(msgpack.unpack(b), o);
    test.deepEqual(msgpack.unpack.bytes_remaining, 0);

    // Expect 3 remaining bytes when unpacking 'bb'
    test.deepEqual(msgpack.unpack(bb), o);
    test.equal(msgpack.unpack.bytes_remaining, 3);

    test.done();
  },
  'circular reference marking algorithm doesn\'t false positive' : function (test) {
    test.expect(1);
    try {
      var d = {};
      for (var i = 0; i < 10; i++) {
        msgpack.pack(d);
      }
      test.ok(true, 'all clear');
    } catch (e) {
      test.ok(false, e.message);
    }
    test.done();
  },
  'test toJSON compatibility' : function (test) {
    var expect = { msg: 'hello world' };
    var subject = { toJSON: function() { return expect; }};
    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(msgpack.pack(subject)));
    test.done();
  },
  'test toJSON compatibility for multiple args' : function (test) {
    var expect = { msg: 'hello world' };
    var subject = { toJSON: function() { return expect; }};
    var subject1 = { toJSON: function() { msg: 'goodbye world' }};
    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(msgpack.pack(subject, subject1)));
    test.done();
  },
  'test toJSON compatibility for nested toJSON' : function (test) {
    var expect = { msg: 'hello world' };
    var subject = {
      toJSON: function() {
        return [
          expect,
          {
            toJSON: function() {
              return expect;
            }
          }
        ];
      }
    };
    test.expect(1);
    test.deepEqual([expect, expect], msgpack.unpack(msgpack.pack(subject)));
    test.done();
  },
  'test fixext 1' : function (test) {
    var raw    = createRawExt(0xd4, 0x0a, 1);
    var expect = createExpectedExtBuffer(0x0a, 1);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  'test fixext 2' : function (test) {
    var raw    = createRawExt(0xd5, 0x0a, 2);
    var expect = createExpectedExtBuffer(0x0a, 2);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  'test fixext 4' : function (test) {
    var raw    = createRawExt(0xd6, 0x0a, 4);
    var expect = createExpectedExtBuffer(0x0a, 4);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  'test fixext 8' : function (test) {
    var raw    = createRawExt(0xd7, 0x0a, 8);
    var expect = createExpectedExtBuffer(0x0a, 8);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  'test fixext 16' : function (test) {
    var raw    = createRawExt(0xd8, 0x0a, 16);
    var expect = createExpectedExtBuffer(0x0a, 16);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  'test ext 8' : function (test) {
    var size;
    var raw;
    var expect;

    // max iterations is (max size - exceptions - starting offset)
    test.expect((1 << 8) - 6);

    for (size = 3; size < (1 << 8); size++) {
      // skip those handled by fixext n
      if (size === 4 || size === 8 || size === 16) {
        continue;
      }

      raw    = createRawExt(0xc7, 0x0a, size);
      expect = createExpectedExtBuffer(0x0a, size);

      test.deepEqual(expect, msgpack.unpack(raw));
    }

    test.done();
  },
  'test ext 16' : function (test) {
    var raw    = createRawExt(0xc8, 0x0a, (1 << 16) - 1);
    var expect = createExpectedExtBuffer(0x0a, (1 << 16) - 1);

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  //'test ext 16 (slow)' : function (test) {
    //var size;
    //var raw;
    //var expect;

    //// max iterations is (max size - starting offset)
    //test.expect((1 << 16) - (1 << 8));

    //for (size = (1 << 8); size < (1 << 16); size++) {
      //raw    = createRawExt(0xc8, 0x0a, size);
      //expect = createExpectedExtBuffer(0x0a, size);

      //test.deepEqual(expect, msgpack.unpack(raw));
    //}

    //test.done();
  //},
  'test ext 32' : function (test) {
    var raw    = createRawExt(0xc9, 0x0a, (1 << 16));
    var expect = createExpectedExtBuffer(0x0a, (1 << 16));

    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(raw));
    test.done();
  },
  //'test ext 32 (slow)' : function (test) {
    //var size;
    //var raw;
    //var expect;

    //// max buffer size is 1GB - 1 byte ( (1 << 30) - 1 )
    //// max iterations is (max size - starting offset)
    //test.expect((1 << 30) - (1 << 16));

    //for (size = (1 << 16); size < (1 << 30); size++) {
      //raw    = createRawExt(0xc9, 0x0a, size);
      //expect = createExpectedExtBuffer(0x0a, size);

      //test.deepEqual(expect, msgpack.unpack(raw));
    //}

    //test.done();
  //},
  'test toJSON compatibility with prototype' : function (test) {
    var expect = { msg: 'hello world' };
    var subject = { __proto__: { toJSON: function() { return expect; }}};
    test.expect(1);
    test.deepEqual(expect, msgpack.unpack(msgpack.pack(subject)));
    test.done();
  },

  /*
   * Warning: This is a little long, because of the conversion of date packing to use
   *          the ext format.
   */
  'test if dates are handled correctly' : function (test) {
    var date          = new Date();
    var packed        = msgpack.pack(date);
    var format_family = packed[0];

    var is_fixext    = (format_family >= 0xd4 && format_family <= 0xd8);
    var is_ext       = (format_family >= 0xc7 && format_family <= 0xc9);

    test.ok(is_fixext || is_ext, "wrong format received");

    var type, size, data;

    if(is_fixext) {
      type = packed[1];
      data = packed.slice(2);
    } else {
      switch(format_family) {
        case 0xc7: // ext8
          size = packed[1];
          type = packed[2];
          data = packed.slice(3);
          break;

        case 0xc8: //ext16
          size = ( packed[1] << 8 ) + packed[2];
          type = packed[3];
          data = packed.slice(4);
          break;

        case 0xc9: //ext16
          size = (packed[1] << 24) + (packed[2] << 16) + (packed[3] << 8)  + packed[4];
          type = packed[5];
          data = packed.slice(6);
          break;

        default:
          test.ok(false, "wrong format received");
      }
    }

    var descriptor = data[0];
    var data       = data.slice(1);
    var resp_sec;
    var resp_nsec;

    // check packed data
    resp_sec = this.checkSeconds(date, descriptor, data, test);
    data     = resp_sec[0];

    resp_nsec = this.checkNanoseconds(date, descriptor, data, test);
    data      = resp_nsec[0];

    data = this.checkTZ(date, descriptor, data, test);

    // check if no trailing bytes
    test.ok(data.length == 0, "trailing bytes found in buffer");

    // "Why is this so weird?", you ask. Well, for example...
    //
    //    * date.getTime() --> 1397203000364
    //
    // But our packed data is this:
    //
    //    * sec  --> 1397203000
    //    * nsec --> 364000000
    //
    // So, to get the proper milliseconds_since_epoch, we have to do this:
    //
    //    * Step 1: Divide <nsec> by 1000000 since precision of nsec in js is 0-999 only
    //    * Step 2: Get <sec>.<nsec>, i.e. 1397203000.364
    //    * Step 3: Multiply result from step 2 by 1000, i.e. 1397203000364
    //
    var ms_since_epoch = ( resp_sec[1] + (( resp_nsec[1] / 1000000) / 1000) ) * 1000;

    // finally, check converted date
    var unpacked_date = new Date(ms_since_epoch);

    test.deepEqual(date, unpacked_date);
    test.equal(date.toISOString(), unpacked_date.toISOString());

    test.done();
  },
};
